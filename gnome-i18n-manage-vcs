#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>

# Author  : Simos Xenitellis <simos@gnome.org>, 2009, 2010.
# Version : 0.95

import dircache                 # dircache.listdir()
import os                       # os.system(), os.remove(), os.path.gmtime(), os.getenv()
import getopt                   # getopt.getopt()
import shutil                   # shutil.rmtree()
import sys                      # sys.argv, sys.exit()
import urllib                   # urllib.urlretrieve()
import ConfigParser             # ConfigParser()
import TextColorPrint   # TextColorPrint()
import GetKey                   # for GetKey.getch()
from datetime import datetime   # datetime()

try:
  XDG_NOT_AVAILABLE = False
  import xdg.BaseDirectory# XDG Python support, BaseDirectory.{xdg_config_home, xdg_data_home}
except ImportError as err:
  XDG_NOT_AVAILABLE = True

import GNOMEI18nTarget

try:
    from lxml import etree      # etree.XMLParser(), etree.XML()
except ImportError as err:
    print 'Import error:', err
    print 'This script requires to have the "python-lxml" package installed'
    print 'Please install the package python-lxml and try again.\nExiting...'
    sys.exit(-10)

PROGNAME='gnome-i18n-manage-vcs'

PACKAGE_NAME    = 'GNOME I18n Manage VCS'
PACKAGE_VERSION = '0.95'
PACKAGE_AUTHORS = ['Simos Xenitellis <simos@gnome.org>', 'Og Maciel <ogmaciel@gnome.org>']
PACKAGE_COPYRIGHT = 'Copyright 2009, 2010 Simos Xenitellis'

class GNOMEI18nManage:
    # Required configuration options
    languagefull = ''
    language = ''
    username = ''

    # Options used for filtering
    all = False
    cache = False
    category = ''
    module = ''
    release = ''
    transtype = ''              # either 'doc' or 'ui' ('document' or 'domain')

    common_short = 'dhv'
    common_long = ['dry-run', 'help', 'verbose']

    filter_short = 'c:m:r:t:'
    filter_long = ['all', 'cache', 'category=', 'module=', 'release=', 'transtype=']

    gnome_release_data = []

    dir_po = ''
    dir_vcs = ''
    file_START = 'START'

    file_CONFIG = ''

    # Text color object
    tc = ''

    action_config = False
    action_status = False
    action_vcsmanage = False
    action_poget = False
    action_commit = False

    opt_commit = False
    opt_clone = False
    opt_dryrun = False
    opt_eponymous = False
    opt_init = False
    opt_cleanall = False
    opt_gitverbose = False
    opt_gitquiet = False
    opt_nocheckout = False
    opt_trim = False
    opt_verbose = False
    opt_vcsreset = False
    opt_vcsupdate = False

    def __init__(self, argv):
        # Initialise the text color object
        self.tc = TextColorPrint.TextColorPrint()

        # getkey object for kbhit()
        self.getkey = GetKey.GetKey()

        # If no args, show basic help.
        if not argv[1:]:
            self.usage(['intro', 'actions', 'help'])
            sys.exit(0)

        if XDG_NOT_AVAILABLE: 
          self.conf_dir = os.path.join(os.path.expanduser('~'), '.' + PROGNAME)
          # Create the directory if it doesn't exist
          if not os.path.isdir(self.conf_dir):
            os.mkdir(self.conf_dir)

          self.data_dir = self.conf_dir
        else:
          # Establish where the configuration file should be stored as per the
          # XDG directories recommendation by the Freedesktop organization.
          self.conf_dir = os.path.join(xdg.BaseDirectory.xdg_config_home, PROGNAME)
          # Create the directory if it doesn't exist
          if not os.path.isdir(self.conf_dir):
                os.mkdir(self.conf_dir)

          self.data_dir = os.path.join(xdg.BaseDirectory.xdg_data_home, PROGNAME)
          # Create the directory if it doesn't exist
          if not os.path.isdir(self.data_dir):
              os.mkdir(self.data_dir)

        # Set the configuration filename and path.
        self.conf_file = os.path.join(self.conf_dir, '%s.conf' % PROGNAME)

        # Identify the action selected.
        if argv[1] == 'config':
                self.action_config = True
        elif argv[1] == 'status':
                self.action_status = True
        elif argv[1] == 'vcsmanage':
            self.action_vcsmanage = True
        elif argv[1] == 'poget':
            self.action_poget = True
        elif argv[1] == 'commit':
            self.action_commit = True
        else:
            self.usage(['intro', 'actions', 'config', 'status', 'vcsmanage',
                        'poget', 'commit', 'filtering', 'common'])
            sys.exit(0)

        # Perform the 'config' action.
        if self.action_config:
            self.process_config(argv[2:])
            sys.exit(0)

        # Read the configuration file.
        self.readconfig()

        # Perform the subsequence actions.
        if self.action_status:
            self.process_status(argv[2:])
        elif self.action_vcsmanage:
            self.process_vcsmanage(argv[2:])
        elif self.action_poget:
            self.process_poget(argv[2:])
        elif self.action_commit:
            self.process_commit(argv[2:])

        # Execution ends.
        print 'Action has just completed.'
        sys.exit(0)

    def highlight(self, str):
        ''' Returns a string with ANSI codes that print as color on the terminal window. '''
        return self.tc.cprint(str, 'red')

    def highlightitem(self, str):
        ''' Returns a string with ANSI codes that print as color on the terminal window. '''
        return self.tc.cprint(str, 'green')

    def highlighttitle(self, str):
        ''' Returns a string with ANSI codes that print as color on the terminal window. '''
        return self.tc.cprint(str, 'blue')

    def process_config(self, cmdargs):
        ''' Process the 'config' action. '''
        # If no arguments, show 'config' specific help.
        if not cmdargs:
            self.usage(['intro', 'config'])
            sys.exit(0)

        # Build command line argument filter.
        try:
            this_filter = [ 'language=', 'languagefull=', 'username=' ];
            this_filter.extend(self.common_long)
            opts, args = getopt.getopt(cmdargs, 'l' + self.common_short, this_filter)
        except getopt.GetoptError as err:
            print 'Error: %s' % str(err)
            self.usage(['intro', 'actions', 'config'])
            sys.exit(0)

        # Retrieve parament values.
        listconfig = False
        for o, a in opts:
            if o in ('-h', '--help'):
                self.usage(['intro', 'actions', 'config', 'status', 'vcsmanage',
                            'poget', 'commit', 'filtering', 'common'])
                sys.exit()
            if o in ('--language'):
                self.language = a
            if o in ('--languagefull'):
                self.languagefull = a
            if o in ('-l'):
                listconfig = True
            if o in ('--username'):
                self.username = a

        # Perform '-l' (list) option.
        if not os.path.exists(self.conf_dir):
            print 'Could not find a configuration file: %s' % self.conf_dir
            print 'Creating new configuration file...'
        elif listconfig:
            self.readconfig()
            print 'Configuration file (%s)' % self.highlight(self.conf_dir)
            print 'Data directory     (%s)' % self.highlight(self.data_dir)
            print
            print 'Full language name =', self.highlight(self.languagefull)
            print 'Language code      =', self.highlight(self.language)
            print 'Username           =', self.highlight(self.username)
            sys.exit(0)

        # Print diagnostics that one of the tuple is not defined.
        if self.language == '' or self.languagefull == '' or self.username == '':
            print 'Error: Required parameter(s) missing for configuration'
            print 'When using the "config" action for the first time, please specify all of the'
            print 'following.'
            print ' 1. --language LANG, language (ISO 639), i.e. en_GB, el, fr, es'
            print ' 3. --languagefull LANGFULL, full language name, i.e. Spanish, Brazilian Portuguese'
            print ' 4. --username USER, username (your git username, or "anonymous" for anonymous clones)'
            print
            print 'Received: language =', self.language, '- full language name =', self.languagefull
            print 'Received: username =', self.username
            print
            print 'Use --help for  more help.'
            print 'Exiting...'
            sys.exit(-1)

        # Make sure we have directories for po and vcs files.
        #self.createreleasedirectory(self.release)

        # Show diagnostics for created directories.
        for dir in [self.dir_po, self.dir_vcs]:
            if not os.path.exists(dir):
                print 'Directory', dir, 'does not exist.'
                print 'Please create it and try again.'
                print 'Exiting...'
                sys.exit(-1)

        # Write back new configuration settings.
        self.writeconfig()

    def process_status(self, cmdargs):
        self.show_status(cmdargs)

    def process_poget(self, cmdargs):
        if not cmdargs:
            self.usage(['intro', 'poget', 'filtering', 'common'])
            sys.exit(0)

        try:
            this_filter_short = self.common_short + self.filter_short
            this_filter_long = ['cleanall']
            this_filter_long.extend(self.common_long)
            this_filter_long.extend(self.filter_long)
            opts, args = getopt.getopt(cmdargs, this_filter_short, this_filter_long)
        except getopt.GetoptError as err:
            print 'Error', err
            self.usage(['intro', 'poget', 'filtering', 'common'])
            sys.exit(0)

        for o, a in opts:
            if o in ('--cleanall'):
                self.opt_cleanall = True
            if o in ('--dryrun', '--dry-run'):
                self.opt_dryrun = True
            if o in ('-h', '--help'):
                self.usage(['intro', 'poget', 'filtering', 'common'])
                sys.exit()
            if o in ('-v', '--verbose'):
                self.opt_verbose = True
            self.apply_filtering(o, a)

        self.verify_filtering()

        self.dir_po, self.dir_vcs = self.get_release_config()

        if self.opt_cleanall:
            podircontents = dircache.listdir(self.dir_po)
            podircontents = podircontents[:]
            try:
                podircontents.remove(self.file_START)
            except ValueError as err:
                pass
            print 'Found', len(podircontents), 'PO files to remove'
            for pofile in podircontents:
                if self.opt_dryrun:
                    print 'To remove', pofile
                else:
                    print 'Removing', pofile
                    os.remove(self.dir_po + pofile)
            sys.exit(0)

        if os.path.exists(self.dir_po + self.file_START) and self.translations_pending():
          print 'A START file already exists, ', self.dir_po + self.file_START
          print 'and there are uncomitted translations. Commit these translations'
          print 'before getting more PO files.'
          sys.exit(-11);

        self.parse_gnome_release_data()
        release = self.gnome_release_data['release']
        language = self.gnome_release_data['language']

        # Create a new directory for this release
        #self.createreleasedirectory(release)

        print self.highlighttitle('Release  :'), self.highlightitem(self.release)
        print self.highlighttitle('Language :'), self.highlightitem(self.language)
        for cat in list(self.gnome_release_data['categories'].keys()):
            if self.category != '' and cat != self.category:
                continue
            print '\n    Category: %(cat)s' % { 'cat': self.highlighttitle(cat) }
            for mod in self.gnome_release_data['categories'][cat]:
                if self.module != '' and mod != self.module:
                    continue
                str_module = 'Module: %(mod)40s' % { 'mod': self.highlight(mod) }
                str_branch = 'Branch: %(br)22s' % { 'br': self.highlight(self.gnome_release_data['categories'][cat][mod]['branch']) }
                print '        %(mod)s, %(br)s' % { 'mod': str_module, 'br': str_branch }
                for resource in self.gnome_release_data['categories'][cat][mod]['resource']:
                    if self.transtype:
                        if resource['id'] not in self.transtype:
                            continue
                    if self.opt_verbose:
                        print '        ID:', resource['id'], 'Type:', resource['type']
                        print '          POFile:', resource['pofile']
                        print '          VCSPath:', resource['vcspath']
                    pofilename = resource['pofile'].rsplit('/')[-1]

                    src_po = 'http://l10n.gnome.org' + resource['pofile']
                    dest_po = self.dir_po + pofilename
                    if self.opt_dryrun:
                      print '           Downloading ' + self.highlightitem(src_po)
                    else:
                      self.download_file(src_po, dest_po)

    def process_vcsmanage(self, cmdargs):
        self.dir_po, self.dir_vcs = self.get_release_config()
        if not cmdargs:
            self.usage(['intro', 'vcsmanage', 'filtering', 'common'])
            sys.exit(0)

        try:
                this_filter_short = self.common_short + self.filter_short
                this_filter_long = ['cleanall',
                'commit', 'clone', 'eponymous',
                'no-checkout',
                'reset', 'git-quiet', 'git-verbose', 'trim',
                'username=', 'update-vcs', 'updatevcs',
                'vcsupdate', 'vcs-update'];
                this_filter_long.extend(self.common_long)
                this_filter_long.extend(self.filter_long)
                opts, args = getopt.getopt(cmdargs, this_filter_short, this_filter_long)
        except getopt.GetoptError as err:
            print 'Error', err
            self.usage(['intro', 'vcsmanage', 'filtering', 'common'])
            sys.exit(0)
        for o, a in opts:
            if o in ('--cleanall'):
                self.opt_cleanall = True
            if o in ('--clone'):
                self.opt_clone = True
            if o in ('--dryrun', '--dry-run'):
                self.opt_dryrun = True
            if o in ('--eponymous'):
                self.opt_eponymous = True
            if o in ('--git-quiet'):
                self.opt_gitquiet = True
            if o in ('--git-verbose'):
                self.opt_gitverbose = True
            if o in ('-h', '--help'):
                self.usage(['intro', 'vcsmanage', 'filtering', 'common'])
                sys.exit()
            if o in ('--no-checkout'):
                self.opt_nocheckout = True
            if o in ('--reset'):
                self.opt_vcsreset = True
            if o in ('--trim'):
                self.opt_trim = True
            if o in ('-v', '--verbose'):
                self.opt_verbose = True
            if o in ('-u', '--username'):
                self.username = a
            if o in ('--update-vcs', '--updatevcs', '--vcs-update', '--vcsupdate'):
                self.opt_vcsupdate = True
            self.apply_filtering(o, a)

        self.verify_filtering()

        if self.opt_vcsreset:
            # Perform hard reset on repositories
            self.perform_on_repositories('git reset --hard origin/master', 'Performing hard reset on')
        elif self.opt_cleanall:
            # Remove all repositories
            self.perform_on_repositories(shutil.rmtree, 'Removing repositories')
        elif self.opt_eponymous:
            # Convert clones to eponymous ones. Sets the username to self.username.
            cmd_remote_url_partial = 'git config remote.origin.url ssh://' + self.username+ '@git.gnome.org/git/'
            self.perform_on_repositories(cmd_remote_url_partial, 'Converting repository to eponymous', append_name = True)
        elif self.opt_trim:
            # Erase the working copy of each repository.
            cmd_erase_working_copy = 'rm -fr ' + self.dir_vcs
            self.perform_on_repositories(cmd_erase_working_copy, 'Erasing working copy for', append_nameslashstar = True)
        elif self.opt_vcsupdate:
            # Perform 'git pull --rebase' for each repository.
            cmd_pull = 'git pull --rebase'
            self.perform_on_repositories(cmd_pull, 'Performing a git pull --rebase in')

        if self.opt_clone:
            # We add more repositories. You can specify single modules, or groups of modules from a release.
            if self.module:
                self.clone_module(self.module, self.username)
            elif self.release:
                print "Cloning release", self.highlight(self.release), "category:", self.highlightitem(self.category)
                self.parse_gnome_release_data()
            else:
                print "You need to specify a release"
            release = self.gnome_release_data['release']
            language = self.gnome_release_data['language']
            self.dir_po, self.dir_vcs = self.get_release_config()
            print 'Language :', self.language
            print 'Directories:', self.dir_po, self.dir_vcs
            for cat in list(self.gnome_release_data['categories'].keys()):
                if self.category != '' and cat != self.category:
                    continue
                print '    Category: %(cat)s' % { 'cat': cat }
                for mod in self.gnome_release_data['categories'][cat]:
                    if self.module != '' and mod != self.module:
                        continue
                    print '        Module: %(br)22s, Branch: %(mod)s' % { 'br': mod, \
                        'mod': self.gnome_release_data['categories'][cat][mod]['branch'] }
                    for resource in self.gnome_release_data['categories'][cat][mod]['resource']:
                        if self.transtype:
                            if resource['id'] not in self.transtype:
                                continue
                        if self.opt_verbose:
                            print '        ID:', resource['id'], 'Type:', resource['type']
                            print '          POFile:', resource['pofile']
                            print '          VCSPath:', resource['vcspath']
                        if self.username == 'anonymous':
                            vcspath = 'git://git.gnome.org/' + mod
                        else:
                            vcspath = 'ssh://' + self.username + '@' + 'git.gnome.org/git/' + mod
                        branch = self.gnome_release_data['categories'][cat][mod]['branch']

                        CMD1 = 'cd ' + self.dir_vcs + ';'
                        if self.opt_gitquiet:
                            if self.opt_nocheckout:
                                CMD1 = CMD1 + 'git clone --no-checkout --quiet ' + vcspath
                            else:
                                CMD1 = CMD1 + 'git clone --quiet ' + vcspath
                        else:
                            if self.opt_nocheckout:
                                CMD1 = CMD1 + 'git clone --no-checkout ' + vcspath
                            else:
                                CMD1 = CMD1 + 'git clone ' + vcspath

                        if self.opt_dryrun and self.opt_verbose:
                            print '            CMD:', CMD1
                        elif not self.opt_dryrun:
                            if os.path.exists(self.dir_vcs + mod):
                                #print 'Cached repository for', mod, 'exists. Skipping cloning...'
                                pass
                            else:
                                print 'Retrieving module', mod, '...'
                                if self.opt_verbose:
                                    print
                                    sys.stdout.flush()
                                os.system(CMD1)
                                if not self.opt_verbose:
                                    sys.stdout.write(' ' * 80 + '\r')
                                    sys.stdout.flush()
            if not self.opt_verbose:
                print ' ' * 80
                pass

    def process_commit(self, cmdargs):
        if not cmdargs:
            self.usage(['intro', 'commit', 'filtering', 'common'])
            sys.exit(0)

        try:
                this_filter_short = self.common_short + self.filter_short
                this_filter_long = ['commit'];
                this_filter_long.extend(self.common_long)
                this_filter_long.extend(self.filter_long)
                opts, args = getopt.getopt(cmdargs, this_filter_short, this_filter_long)
        except getopt.GetoptError as err:
            print 'Error', err
            self.usage(['intro', 'commit', 'filtering', 'common'])
            sys.exit(0)
        for o, a in opts:
            if o in ('--commit'):
                self.opt_commit = True
            if o in ('--dryrun', '--dry-run'):
                self.opt_dryrun = True
            if o in ('-h', '--help'):
                self.usage(['intro', 'commit', 'filtering', 'common'])
                sys.exit()
            if o in ('-v', '--verbose'):
                self.opt_verbose = True
            self.apply_filtering(o, a)

        #self.verify_filtering()
        self.dir_po, self.dir_vcs = self.get_release_config()

        if self.opt_commit:
          vcsdircontents = dircache.listdir(self.dir_vcs)
          vcsdircontents = vcsdircontents[:]
          podircontents = dircache.listdir(self.dir_po)
          podircontents = podircontents[:]
          try:
            podircontents.remove(self.file_START)
          except:
            pass
          start_time = os.stat(self.dir_po + self.file_START).st_mtime
          for pofile in podircontents:
            fileparts = pofile.split('.')
            try:
                if fileparts[0][-5:] != '-help':
                    modulename = fileparts[0]
                    translationtype = '/po/'
                else:
                    modulename = fileparts[0][:-5]
                    translationtype = '/help/' + self.language + '/'
                branchname = fileparts[1]
                languagename = fileparts[2]
                extensionname = fileparts[3]
            except IndexError as err:
                print 'Error with', pofile
                sys.exit(13)
            if self.language != languagename:
                print 'Internal error: Language in config does not match language in PO files.'
                print 'Exiting...'
                sys.exit(-11)
            if start_time < os.stat(self.dir_po + pofile).st_mtime:
                if self.opt_verbose:
                    destination =  self.dir_vcs + \
                        modulename + translationtype + languagename + '.' + extensionname
                    print 'Copying', self.dir_po + pofile, 'to', destination
                    try:
                        os.stat(destination)
                    except OSError as err:
                        print 'but', destination, 'is not there'
                if not self.opt_dryrun:
                    shutil.copyfile(self.dir_po + pofile,  pofile)

    def show_status(self, cmdargs):
        ''' Show status information of the current localisation files. '''
        # Retrieve PO and VCS directory values.
        self.dir_po, self.dir_vcs = self.get_release_config()

        # Perform check for VCS directory.
        if not os.path.isdir(self.dir_vcs):
            print 'The release you have entered has not been configured yet.'
            print 'Please provide the name of a valid release or make sure to'
            print ' configure it first.'
            sys.exit(0)

        # Print general configuration information.
        print '%(lc)s [%(lang)s]\t %(lf)s %(langfull)s\t %(un)s %(u)s' % \
            { 'lc': self.highlighttitle('Language code:'),
              'lang': self.highlight(self.language),
              'lf': self.highlighttitle('Language:'),
              'langfull': self.highlight(self.languagefull), 
              'un': self.highlighttitle('Username:'),
              'u': self.highlight(self.username) }
        print
        print self.highlighttitle('VCS Directory:'), self.highlight(self.dir_vcs)
        print self.highlighttitle('PO  Directory:'), self.highlight(self.dir_po)
        print

        # Show found repositories, PO files.
        dircontents = dircache.listdir(self.dir_vcs)
        dircontents = dircontents[:]
        print self.highlight(str(len(dircontents))), 'repositories found:'
        for repo in dircontents:
            print '\t', self.highlightitem(repo)
        if os.path.exists(self.dir_po) or self.dir_po:
            podircontents = dircache.listdir(self.dir_po)
            podircontents = podircontents[:]
            try:
                podircontents.remove(self.file_START)
            except ValueError as err:
                pass
            print self.highlight(str(len(podircontents))), 'PO files found:'
            for pofile in podircontents:
                print '\t', self.highlightitem(pofile)
        else:
            print 'No PO directory has been specified. Please specify'
            print 'such a directory with the "config" action.'
            print 'Exiting...'
            sys.exit(-1)
        # Show PO file details
        try:
            start_time = os.stat(self.dir_po + '/' + self.file_START).st_mtime
        except OSError:
            start_time = 0
        if start_time:
            print 'Timestamp file START has date/time:',  datetime.ctime(datetime.fromtimestamp(start_time))
        else:
            print 'No START file exists'
        print 'PO files that are newer than timestamp:'
        for pofile in podircontents:
            potime = os.stat(self.dir_po + pofile).st_mtime
            if start_time < potime:
                print '\t', datetime.ctime(datetime.fromtimestamp(potime)), '\t', self.highlightitem(pofile)

    def translations_pending(self):
        try:
            start_time = os.stat(self.dir_po + '/' + self.file_START).st_mtime
        except OSError:
            start_time = 0
        podircontents = dircache.listdir(self.dir_po)
        for pofile in podircontents:
            potime = os.stat(self.dir_po + pofile).st_mtime
            if start_time < potime:
              return True
        return False

    def get_po_file_data(self, pofile):
        if not self.gnome_release_data:
            self.parse_gnome_release_data()

        if self.gnome_release_data['release'] != self.release:
            print 'Mismatched release data', self.release, self.gnome_release_data['release']
        if self.gnome_release_data['language'] != self.language:
            print 'Mismatched language data', self.language, self.gnome_release_data['language']
        for cat in list(self.gnome_release_data['categories'].keys()):
            if self.category != '' and cat != self.category:
                continue
            for mod in self.gnome_release_data['categories'][cat]:
                if self.module != '' and mod != self.module:
                    continue
                for resource in self.gnome_release_data['categories'][cat][mod]['resource']:
                    if pofile == resource['pofile'].rsplit('/')[-1]:
                        return resource['vcspath']
        return None

    def is_empty(self):
        for dir in [self.dir_po]:
            dircontents = dircache.listdir(dir)
            dircontents = dircontents[:]
            if dircontents:
                return False
        return True

    def perform_on_repositories(self, command, description, append_name = False, append_nameslashstar = False):
        dircontents = dircache.listdir(self.dir_vcs)
        dircontents = dircontents[:]
        if dircontents:
            count = 1
            total = len(dircontents)
            for item in dircontents:
                if self.getkey.kbhit():
                    print self.highlight('A key was pressed; interrupting the process')
                    return
                if self.module != '' and item != self.module:
                    continue
                if os.path.isdir(self.dir_vcs + item):
                    if type(command).__name__ == 'function':
                        if self.opt_verbose:
                            indexnums = self.highlight('%(aa)3d/%(total)d' % { 'aa': count, 'total': total })
                            print '%(index)s -- Running function on %(dir)s' % \
                                { 'index': indexnums, 'dir': self.highlightitem(self.dir_vcs + item) }
                        if not self.opt_dryrun:
                            command(self.dir_vcs + item)
                        else:
                            print '\tcmd(' + self.dir_vcs + item + ')'
                    elif type(command).__name__ == 'str':
                        CMD = 'cd ' + self.dir_vcs + item + '; ' + command
                        if append_name:
                            CMD = CMD + item
                        elif append_nameslashstar:
                            CMD = CMD + item + '/*'
                        if self.opt_verbose:
                            print '%(aa)3d/%(total)d -- Running command %(cmd)s' % \
                                { 'aa': count, 'total': total, 'cmd': CMD }
                        if not self.opt_dryrun:
                            indexnums = self.highlight('%(aa)3d/%(total)d' % { 'aa': count, 'total': total })
                            print '%(index)s -- %(desc)s %(dir)s' % \
                                { 'index': indexnums, 'desc': self.highlighttitle(description), 'dir': self.highlightitem(self.dir_vcs + item) }
                            os.system(CMD)
                        else:
                            print '\t', self.highlighttitle(description), self.highlightitem(self.dir_vcs + item)
                            print '\t', CMD
                    else:
                        print 'Error, unknown type', type(command)
                        sys.exit(-1)
                count += 1

    def init(self):
        if self.opt_dryrun:
            self.process_stats('print')
        else:
            self.process_stats('execute')

    def parse_gnome_release_data(self):
        filename = 'managevcs-%s-%s.xml' % (self.language, self.release)
        filepath = os.path.join(os.curdir, filename)

        # If a file already exists and we are allowed to cache, 
        if os.path.getsize(filepath) and self.cache:
          if (self.opt_verbose):
            print 'Using cached GNOME release data for', self.release
          self.gnome_release_data = self.parse_gnome_xml_file(filepath)
          return
    
        xmlurl = 'http://l10n.gnome.org/languages/' + self.language + '/' + self.release + '/xml'
        self.download_file(xmlurl, filepath)

        # An error page is about 2.5KB, a proper XML file is circa 50KB.
        if os.path.getsize(filepath) < 5000:
            print 'Language', self.language, 'was not found.\nExiting...'
            print 'The URL was: ', xmlurl
            os.remove(filepath)
            sys.exit(-7)

        if (self.opt_verbose):
          print 'Retrieved GNOME release data for', self.release, xmlurl
        self.gnome_release_data = self.parse_gnome_xml_file(filepath)

    def parse_gnome_xml_file(self, filename):
        try:
            xmlfile = open(filename, 'r')
            xmlfile.close
        except OSError:
            print 'Could not open file ', filename, '. Aborting...'
            sys.exit(-1)

        contents = ''.join(xmlfile.readlines())

        mytarget = GNOMEI18nTarget.GNOMEI18nTarget()
        parser = etree.XMLParser(target = mytarget)
        result = etree.XML(contents, parser)

        return mytarget.get_stats()

    def usage(self, helpIDs):
        # Help text message
        help_intro = self.highlight('gnome-i18n-manage-vcs') + ', ' + self.highlightitem('a tool that helps manage translation files from GNOME VCS') + \
        """\nUsage: gnome-i18n-manage-vcs <action> <options>\n"""

        help_actions = """Please specify action. Available actions are:
\t* """ + self.highlight('config') + """       configures the local settings
\t* """ + self.highlight('status') + """       show detailed status of local files
\t* """ + self.highlight('vcsmanage') + """    repository management tasks
\t* """ + self.highlight('poget') + """        retrieval of PO files
\t* """ + self.highlight('commit') + """       commiting PO files
"""

        help_config = self.highlight('config') + self.highlighttitle('     Initial configuration') + """
\t\t--language LANG     specify the language code per ISO 639
\t\t--languagefull LANGFULL  specify the full language name (such as 'Brazilian Portuguese')
\t\t--username USER     specify username USR (corresponds to SVN/GIT GNOME account)
\t-l                          list the configuration options
"""

        help_status = self.highlight('status') + self.highlighttitle('      Show current status for a previously configured release.') + '\n'

        help_vcsmanage = self.highlight('vcsmanage') + self.highlighttitle('   Local repository management (Module filtering applies)') + """
\t\t--cleanall      cleans up the repository folder (USE WITH CARE, WIPES REPOSITORIES)
\t\t--clone         clone repositories
\t\t--eponymous     make repositories eponymous (sets to new 'username')
\t\t--git-quiet      don't show progress when cloning (git 1.5 ignores this option).
\t\t--git-verbose    show progress when cloning
\t\t--reset         reset each repository (git reset --hard origin/master)
\t\t--trim          erases the working copy
\t\t--update-vcs    update local repositories (runs git pull --rebase on each)
"""

        help_poget = self.highlight('poget') + self.highlighttitle('       Retrieve a selection of PO files (Module filtering required)') + """
\t\t--cleanall      clears up the downloaded files (USE WITH CARE, WIPES PO FILES)
"""

        help_commit = self.highlight('commit') + self.highlighttitle('    Commit and push the translation work to the repositories') + """
\t\t--commit        commit changes in repositories
\t\t--dry-run       do not really checkout/commit
"""

        help_filtering = self.highlighttitle('Module filtering  (applies to vcsmanage, poget, commit)') + """
\t        --all               apply action to all locally available repositories
\t        --cache             use the cached XML file (if any) of the release modules
\t-c CAT  --category CAT      i18n category name CAT (such as 'desktop')
\t-m MODU --module MOD        i18n module name MOD (such as 'gnome-games')
\t-r REL  --release REL       GNOME release (such as 'gnome-2-30')
\t-t TYPE --transtype TYPE    optionally specify translation type, either ui or doc
"""

        help_common = self.highlighttitle('Common options') + """
\t-d      --dry-run           do not really perform the action
\t-h      --help              this craft
\t-v      --verbose           show verbose output
"""

        help_help = """Invoke with --help for full help options."""

        help_messages = {
            'intro': help_intro,
            'actions': help_actions,
            'config': help_config,
            'status': help_status,
            'vcsmanage': help_vcsmanage,
            'poget': help_poget,
            'commit': help_commit,
            'filtering': help_filtering,
            'common': help_common,
            'help': help_help
        }

        for id in helpIDs:
            print help_messages[id]

    def download_hook(self, blocks_transferred, block_size, file_size):
        """ A download hook to provide some feedback when downloading """
        if blocks_transferred == 0:
            if file_size > 0:
                if self.opt_verbose:
                    sys.stdout.write('Downloading ' + str(file_size) + ' bytes: ')
                else:
                    if self.opt_verbose:
                        sys.stdout.write('Downloading: ')
        if self.opt_verbose:
            sys.stdout.write('#')
            sys.stdout.flush()


    def download_file(self, url, filepath):
        """
        Downloads a file provided a URL and saves it as filepath.
        """

        if self.opt_verbose:
            sys.stdout.write('Downloading ' + url + ' ')
        # Download the file, regardless if it exists or not.
        try:
            urllib.urlretrieve(url, filepath, self.download_hook)
        except IOError as data_ioerror:
            (errno, strerror) = data_ioerror.args
            if self.opt_verbose:
                print
            print 'While trying to download', url
            print 'I/O error(%s): %s' % (errno, strerror)
            sys.exit(-1)
        except OSError as err:
            print 'Unexpected error: ', err
            sys.exit(-1)

        if self.opt_verbose:
            print ' done.'

    def createreleasedirectory(self, release):
        """
        Creates the directories required to save files for a given release.
        """

        # TODO: the po and vcs files should be variables and the final path
        # could be an attribute of the release itself.

        # First a directory for the release
        if not os.path.isdir(os.path.join(self.data_dir, release)):
            os.mkdir(os.path.join(self.data_dir, release))

        # Now a directory to store the PO files...
        self.dir_po = os.path.join(self.data_dir, release, 'po')
        if not os.path.isdir(self.dir_po):
            os.mkdir(self.dir_po)

        # ... and a directory to store the VCS files from a clone
        self.dir_vcs = os.path.join(self.data_dir, release, 'vcs')
        if not os.path.isdir(self.dir_vcs):
            os.mkdir(self.dir_vcs)

    def writeconfig(self):
        config = ConfigParser.ConfigParser()

        try:
            config.add_section('GNOME-I18n-Manage-VCS')
            if self.language:
                config.set('GNOME-I18n-Manage-VCS', 'language', self.language)
            if self.languagefull:
                config.set('GNOME-I18n-Manage-VCS', 'languagefull', self.languagefull)
            if self.username:
                config.set('GNOME-I18n-Manage-VCS', 'username', self.username)
            #self.dir_vcs = os.path.join(self.data_dir, self.release, 'vcs/')
            #config.set('GNOME-I18n-Manage-VCS', 'vcsdir', self.dir_vcs)
            #self.dir_po = os.path.join(self.data_dir, self.release, 'po/')
            #config.set('GNOME-I18n-Manage-VCS', 'podir', self.dir_po)
        except ConfigParser.NoOptionError as err:
            print 'Error:', err
            sys.exit(10)

        try:
            cf = open(self.conf_file, 'wb')
            config.write(cf)
            cf.close()
        except Exception as e:
            print 'Oooops'

    def readconfig(self):
        """
        Reads the existing configuration file.
        """
        config = ConfigParser.ConfigParser()

        if os.path.exists(self.conf_file):
            config.read(self.conf_file)

            try:
                self.language = config.get('GNOME-I18n-Manage-VCS', 'language')
                self.languagefull = config.get('GNOME-I18n-Manage-VCS', 'languagefull')
                self.username = config.get('GNOME-I18n-Manage-VCS', 'username')
                #self.dir_po = os.path.join(self.data_dir, self.release, 'po/')
                #self.dir_vcs = os.path.join(self.data_dir, self.release, 'vcs/')
            except ConfigParser.NoOptionError as err:
                if not self.action_config:
                    print 'Error:', str(err)
                    print 'Please use --config and the relevant argument to set the missing setting'
                    print 'Exiting...'
                    sys.exit(10)
        #else:
        #    print "The configuration file %s was not found." % self.conf_file
        #    print "It is required to perform the initial configuration, before issuing commands."
        #    sys.exit(10)

    def get_release_config(self):
        dir_po = os.path.join(self.data_dir, 'po/')
        dir_vcs = os.path.join(self.data_dir, 'vcs/')

        return dir_po, dir_vcs

    def apply_filtering(self, o, a):
        if o in ('--all'):
            self.all = True
        if o in ('--cache'):
            self.cache = True
        if o in ('-c', '--category'):
            self.category = a
        if o in ('-m', '--module'):
            self.module = a
        if o in ('-r', '--release'):
            self.release = a
        if o in ('--transtype'):
            if a in ['ui', 'domain']:
                self.transtype = 'domain'
            elif a in ['doc', 'document']:
                self.transtype = 'document'
            else:
                print 'ERROR: Invalid transtype, expected on of ui, doc, domain, document'
                sys.exit(-4)

    def verify_filtering(self):
        if self.all == False and self.category == '' and self.module == '' and self.release == '' and self.transtype == '':
            if not self.opt_cleanall:
                print 'Error: It is required to specify at least one of release, category, module or translation type, or specify all.'
                sys.exit(8)

    def clone_module(self, mod, user):
        ''' Runs a git clone on the module requested. '''
        print 'Cloning module',  self.highlight(mod) + '...'
        CMD = 'cd ' + self.dir_vcs + ';'
        if user == 'anonymous':
            vcspath = 'git://git.gnome.org/' + mod
        else:
            vcspath = 'ssh://' + user + '@' + 'git.gnome.org/git/' + mod
        if self.opt_gitquiet:
            if self.opt_nocheckout:
                CMD = CMD + 'git clone --no-checkout --quiet ' + vcspath
            else:
                CMD = CMD + 'git clone --quiet ' + vcspath
        else:
            if self.opt_nocheckout:
                CMD = CMD + 'git clone --no-checkout ' + vcspath
            else:
                CMD = CMD + 'git clone ' + vcspath

        if self.opt_dryrun:
            print '\tCMD:', CMD
        else:
            if os.path.exists(self.dir_vcs + mod):
                print 'Repository for', mod, 'already exists. We skip cloning...'
                return
            else:
                os.system(CMD)
        return

if __name__ == '__main__':
    start = GNOMEI18nManage(sys.argv)
