#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>

# Author  : Simos Xenitellis <simos@gnome.org>, 2009
# Version : 0.9

import dircache                 # dircache.listdir()
import os                       # os.system(), os.remove(), os.path.gmtime(), os.getenv()
import getopt                   # getopt.getopt()
import shutil                   # shutil.rmtree()
import sys                      # sys.argv, sys.exit()
import urllib                   # urllib.urlretrieve()
import ConfigParser as configparser             # ConfigParser()
from datetime import datetime   # datetime()

from xdg.BaseDirectory import * # XDG Python support, ...

import GNOMEI18nTarget

try:
    from lxml import etree      # etree.XMLParser(), etree.XML()
except ImportError as err:
    print('Import error:', err)
    print('This script requires to have the "python-lxml" package installed')
    print('Please install the package python-lxml and try again.\nExiting...')
    sys.exit(-10)

PROGNAME='gnome-i18n-manage-vcs'

PACKAGE_NAME    = 'GNOME I18n Manage VCS'
PACKAGE_VERSION = '0.9'
PACKAGE_AUTHORS = ['Simos Xenitellis <simos@gnome.org>', 'Og Maciel <ogmaciel@gnome.org>']
PACKAGE_COPYRIGHT = 'Copyright 2009 Simos Xenitellis'

class GNOMEI18nManage:
    # Required configuration options
    language = ''
    languagefull = ''
    username = ''

    # Options used for filtering
    category = ''
    module = ''
    release = ''
    transtype = ''              # either 'doc' or 'ui' ('document' or 'domain')

    common_short = 'dhv'
    common_long = ['dry-run', 'help', 'verbose']

    filter_short = 'c:m:r:t:'
    filter_long = ['category=', 'module=', 'release=', 'transtype=']

    gnome_release_data = []

    dir_po = ''
    dir_vcs = ''
    file_START = 'START'

    file_CONFIG = ''

    action_config = False
    action_status = False
    action_vcsmanage = False
    action_poget = False
    action_commit = False

    opt_commit = False
    opt_clone = False
    opt_dryrun = False
    opt_eponymous = False
    opt_init = False
    opt_cleanall = False
    opt_gitverbose = False
    opt_nocheckout = False
    opt_trim = False
    opt_verbose = False
    opt_vcsreset = False
    opt_vcsupdate = False

    def __init__(self, argv):
        if not argv[1:]:
            self.usage(['intro', 'actions', 'help'])
            sys.exit(0)

        # Establish where the configuration file should be stored as per the
        # XDG directories recommendation by the Freedesktop organization.
        self.conf_dir = os.path.join(xdg_config_home, PROGNAME)
        # Create the directory if it doesn't exist
        if not os.path.isdir(self.conf_dir):
            os.mkdir(self.conf_dir)

        self.data_dir = os.path.join(xdg_data_home, PROGNAME)
        # Create the directory if it doesn't exist
        if not os.path.isdir(self.data_dir):
            os.mkdir(self.data_dir)

        # Configuration file
        self.conf_file = os.path.join(self.conf_dir, '%s.conf' % PROGNAME)

        if argv[1] == 'config':
                self.action_config = True
        elif argv[1] == 'status':
                self.action_status = True
        elif argv[1] == 'vcsmanage':
            self.action_vcsmanage = True
        elif argv[1] == 'poget':
            self.action_poget = True
        elif argv[1] == 'commit':
            self.action_commit = True
        else:
            self.usage(['intro', 'actions', 'config', 'status', 'vcsmanage', 
                        'poget', 'commit', 'filtering', 'common'])
            sys.exit(0)

        if self.action_config:
            self.process_config(argv[2:])
            sys.exit(0)

        self.readconfig()

        if self.action_status:
            self.process_status(argv[2:])
        elif self.action_vcsmanage:
            self.process_vcsmanage(argv[2:])
        elif self.action_poget:
            self.process_poget(argv[2:])
        elif self.action_commit:
            self.process_commit(argv[2:])

        print("Action has just completed.")
        sys.exit(0)

    def process_config(self, cmdargs):
        if not cmdargs:
            self.usage(['intro', 'config'])
            sys.exit(0)

        try: 
            this_filter = [ 'language=', 'languagefull=', 'status', 'username=' ];
            this_filter.extend(self.common_long)
            opts, args = getopt.getopt(cmdargs, 'ls' + self.common_short, this_filter)
        except getopt.GetoptError as err:
            print('Error: %s' % str(err))
            self.usage(['intro', 'actions', 'config'])
            sys.exit(0)

        listconfig = False
        for o, a in opts:
            if o in ('-h', '--help'):
                self.usage(['intro', 'actions', 'config', 'status', 'vcsmanage', 
                            'poget', 'commit', 'filtering', 'common'])
                sys.exit()
            if o in ('--language'):
                self.language = a
            if o in ('--languagefull'):
                self.languagefull = a
            if o in ('-l'):
                listconfig = True
            if o in ('-s', '--status'):
                self.opt_status = True
            if o in ('--username'):
                self.username = a
            if o in ('-v', '--verbose'):
                self.opt_verbose = True

        if not os.path.exists(self.conf_dir):
            print('Could not find a configuration file: %s' % self.conf_dir)
            print('Creating new configuration file...')
        elif listconfig:
            self.readconfig()
            print('Configuration (%s)' % self.conf_dir)
            print()
            print('Language code =', self.language)
            print('Full language name =', self.languagefull)
            print('Username =', self.username)
            sys.exit(0)

        if self.language == '' or self.languagefull == '' or self.username == '':
            print('Error: Required parameter(s) missing for configuration')
            print('When using the "config" action for the first time, please specify all of the')
            print('following.')
            print(' 1. --language LANG, language (ISO 639), i.e. en_GB, el, fr, es')
            print(' 3. --languagefull LANGFULL, full language name, i.e. Spanish, Brazilian Portuguese')
            print(' 4. --username USER, username (your git username, or "anonymous" for anonymous clones)')
            print()
            print('Received: language =', self.language, '- full language name =', self.languagefull)
            print('Received: username =', self.username)
            print()
            print('Use --help for  more help.')
            print('Exiting...')
            sys.exit(-1)

        # Make sure we have directories for po and vcs files.
        self.createreleasedirectory(self.release)

        for dir in [self.dir_po, self.dir_vcs]:
            if not os.path.exists(dir):
                print('Directory', dir, 'does not exist.')
                print('Please create it and try again.')
                print('Exiting...')
                sys.exit(-1)

        self.writeconfig()

        if self.opt_verbose:
            print('Use "config --status" to view the current configuration settings.')

    def process_status(self, cmdargs):
        self.show_status(cmdargs)

    def process_poget(self, cmdargs):
        if not cmdargs:
            self.usage(['intro', 'poget', 'filtering', 'common'])
            sys.exit(0)

        try:
            this_filter_short = self.common_short + self.filter_short
            this_filter_long = ['cleanall']
            this_filter_long.extend(self.common_long)
            this_filter_long.extend(self.filter_long)
            opts, args = getopt.getopt(cmdargs, this_filter_short, this_filter_long)
        except getopt.GetoptError as err:
            print('Error', err)
            self.usage(['intro', 'poget', 'filtering', 'common'])
            sys.exit(0)

        for o, a in opts:
            if o in ('--cleanall'):
                self.opt_cleanall = True
            if o in ('--dryrun', '--dry-run'):
                self.opt_dryrun = True
            if o in ('-h', '--help'):
                self.usage(['intro', 'poget', 'filtering', 'common'])
                sys.exit()
            if o in ('-v', '--verbose'):
                self.opt_verbose = True
            self.apply_filtering(o, a)

        self.verify_filtering()

        if not os.path.isdir(os.path.join(self.data_dir, self.release)):
            print("The release you've entered has not been configured yet.")
            print("Please provide the name of a valid release or make sure to")
            print(" configure it first.")
            sys.exit(0)

        self.dir_po, self.dir_vcs = self.get_release_config(self.release)

        if self.opt_cleanall:
            podircontents = dircache.listdir(self.dir_po)
            podircontents = podircontents[:]
            try: 
                podircontents.remove(self.file_START)
            except ValueError as err:
                pass
            print('Found', len(podircontents), 'PO files to remove') 
            for pofile in podircontents:
                if self.opt_dryrun:
                    print('To remove', pofile)
                else:
                    print('Removing', pofile)
                    os.remove(self.dir_po + pofile)
            sys.exit(0)

        self.parse_gnome_release_data() 
        release = self.gnome_release_data['release']
        language = self.gnome_release_data['language']

        # Create a new directory for this release
        self.createreleasedirectory(release)

        print('Release  :', self.release)
        print('Language :', self.language)
        for cat in list(self.gnome_release_data['categories'].keys()):
            if self.category != '' and cat != self.category:
                continue
            print('    Category: %(cat)s' % { 'cat': cat })
            for mod in self.gnome_release_data['categories'][cat]:
                if self.module != '' and mod != self.module:
                    continue
                print('        Module: %(br)22s, Branch: %(mod)s' % { 'br': mod, \
                    'mod': self.gnome_release_data['categories'][cat][mod]['branch'] })
                for resource in self.gnome_release_data['categories'][cat][mod]['resource']:
                    if self.transtype: 
                        if resource['id'] not in self.transtype:
                            continue
                    if self.opt_verbose:
                        print('        ID:', resource['id'], 'Type:', resource['type'])
                        print('          POFile:', resource['pofile'])
                        print('          VCSPath:', resource['vcspath'])
                    pofilename = resource['pofile'].rsplit('/')[-1]

                    src_po = 'http://l10n.gnome.org' + resource['pofile']
                    dest_po = self.dir_po + pofilename
                    self.download_file(src_po, dest_po)

                    print('\t\tTouching current time at', self.dir_po + self.file_START)
                    os.system('touch ' + self.dir_po + self.file_START)
                    os.system(CMD2)

    def process_vcsmanage(self, cmdargs):
        self.dir_po, self.dir_vcs = self.get_release_config(self.release)
        if not cmdargs:
            self.usage(['intro', 'vcsmanage', 'filtering', 'common'])
            sys.exit(0)

        try:
                this_filter_short = self.common_short + self.filter_short
                this_filter_long = ['cleanall', 
                'commit', 'clone', 'eponymous',
                'no-checkout',
                'reset', 'gitverbose', 'trim',
                'username=', 'update-vcs', 'updatevcs', 
                'vcsupdate', 'vcs-update'];
                this_filter_long.extend(self.common_long)
                this_filter_long.extend(self.filter_long)
                opts, args = getopt.getopt(cmdargs, this_filter_short, this_filter_long) 
        except getopt.GetoptError as err:
            print('Error', err)
            self.usage(['intro', 'vcsmanage', 'filtering', 'common'])
            sys.exit(0)
        for o, a in opts:
            if o in ('--cleanall'):
                self.opt_cleanall = True
            if o in ('--clone'):
                self.opt_clone = True
            if o in ('--dryrun', '--dry-run'):
                self.opt_dryrun = True
            if o in ('--eponymous'):
                self.opt_eponymous = True
            if o in ('--gitverbose'):
                self.opt_gitverbose = True
            if o in ('-h', '--help'):
                self.usage(['intro', 'vcsmanage', 'filtering', 'common'])
                sys.exit()
            if o in ('--no-checkout'):
                self.opt_nocheckout = True
            if o in ('--reset'):
                self.opt_vcsreset = True
            if o in ('--trim'):
                self.opt_trim = True
            if o in ('-v', '--verbose'):
                self.opt_verbose = True
            if o in ('-u', '--username'):
                self.username = a
            if o in ('--update-vcs', '--updatevcs', '--vcs-update', '--vcsupdate'):
                self.opt_vcsupdate = True
            self.apply_filtering(o, a)

        self.verify_filtering()

        if self.opt_vcsreset:
            self.reset_hard(self.dir_vcs)

        if self.opt_clone:
            #self.parse_gnome_release_data()
            #release = self.gnome_release_data['release']
            #language = self.gnome_release_data['language']
            #self.dir_po, self.dir_vcs = self.get_release_config(self.release)
            print('Release  :', self.release)
            print('Language :', self.language)
            print('Directories:', self.dir_po, self.dir_vcs)
            for cat in list(self.gnome_release_data['categories'].keys()):
                if self.category != '' and cat != self.category:
                    continue
                print('    Category: %(cat)s' % { 'cat': cat })
                for mod in self.gnome_release_data['categories'][cat]:
                    if self.module != '' and mod != self.module:
                        continue
                    print('        Module: %(br)22s, Branch: %(mod)s' % { 'br': mod, \
                        'mod': self.gnome_release_data['categories'][cat][mod]['branch'] })
                    for resource in self.gnome_release_data['categories'][cat][mod]['resource']:
                        if self.transtype: 
                            if resource['id'] not in self.transtype:
                                continue
                        if self.opt_verbose:
                            print('        ID:', resource['id'], 'Type:', resource['type'])
                            print('          POFile:', resource['pofile'])
                            print('          VCSPath:', resource['vcspath'])
                        if self.username == 'anonymous':
                            vcspath = 'git://git.gnome.org/' + mod
                        else:
                            vcspath = 'ssh://' + self.username + '@' + 'git.gnome.org/git/' + mod
                        branch = self.gnome_release_data['categories'][cat][mod]['branch']
    
                        CMD1 = 'cd ' + self.dir_vcs + ';'
                        if self.opt_gitverbose:
                            if self.opt_nocheckout:
                                CMD1 = CMD1 + 'git clone --no-checkout ' + vcspath
                            else:
                                CMD1 = CMD1 + 'git clone ' + vcspath
                        else:
                            if self.opt_nocheckout:
                                CMD1 = CMD1 + 'git clone --no-checkout --quiet ' + vcspath
                            else:
                                CMD1 = CMD1 + 'git clone --quiet ' + vcspath

                        if self.opt_dryrun and self.opt_verbose:
                            print('            CMD:', CMD1)
                        elif not self.opt_dryrun:
                            if os.path.exists(self.dir_vcs + mod):
                                #print 'Cached repository for', mod, 'exists. Skipping cloning...'
                                pass
                            else:
                                print('Retrieving module', mod, '...')
                                if self.opt_verbose: 
                                    print()
                                    sys.stdout.flush()
                                os.system(CMD1)
                                if not self.opt_verbose:
                                    sys.stdout.write(' ' * 80 + '\r')
                                    sys.stdout.flush()
            if not self.opt_verbose:
                print(' ' * 80) 
                pass

        if self.opt_cleanall:
            self.do_cleanall(self.dir_vcs)

        if self.opt_eponymous:
            dircontents = dircache.listdir(self.dir_vcs)
            dircontents = dircontents[:]
            if self.username == 'anonymous':
                print('In order to use --eponymous, you need to set the username to')
                print('something other than "anonymous".')
                print('Exiting...')
                sys.exit(-1)
            cmd_remote_rm = 'git remote rm origin'
            cmd_remote_origin = 'git config branch.master.remote origin'
            cmd_remote_merge = 'git config branch.master.merge refs/heads/master'
            counter = 1
            for vcsdir in dircontents:
                print('Converting', self.dir_vcs + vcsdir, ' -- ', counter, 'of', len(dircontents))
                cmd_changedir = 'cd ' + self.dir_vcs + vcsdir
                cmd_remote_add = 'git remote add origin -m master -f ssh://' + self.username \
                    + '@git.gnome.org/git/' + vcsdir + '/'
                if self.opt_dryrun:
                    cmd_changedir + ';' + cmd_remote_rm
                    cmd_changedir + ';' + cmd_remote_add
                    cmd_changedir + ';' + cmd_remote_origin
                    cmd_changedir + ';' + cmd_remote_merge
                else:
                    try: 
                        print(os.system(cmd_changedir + ';' + cmd_remote_rm))
                        print(os.system(cmd_changedir + ';' + cmd_remote_add))
                        print(os.system(cmd_changedir + ';' + cmd_remote_origin))
                        print(os.system(cmd_changedir + ';' + cmd_remote_merge))
                    except OSError as err:
                        print(err)
                        sys.exit(-1)
                counter = counter + 1

        if self.opt_trim:
            dircontents = dircache.listdir(self.dir_vcs)
            dircontents = dircontents[:]
            counter = 1
            for vcsdir in dircontents:
                print('Erasing working copy for', self.dir_vcs + vcsdir, ' -- ', counter, 'of', len(dircontents))
                if self.opt_dryrun:
                    print('rm -fr ' + self.dir_vcs + vcsdir + '/*')
                else:
                    os.system('rm -fr ' + self.dir_vcs + vcsdir + '/*')
                counter = counter + 1

        if self.opt_vcsupdate:
            dircontents = dircache.listdir(self.dir_vcs)
            dircontents = dircontents[:]
            cmd_pull = 'git pull --rebase'
            counter = 1
            for vcsdir in dircontents:
                # We commit irrespective of any changed files; if files are not changed, 
                # no harm is done.
                ###if self.opt_verbose:
                print('Pulling for', self.dir_vcs + vcsdir, ' -- ', counter, 'of', len(dircontents))
                cmd_changedir = 'cd ' + self.dir_vcs + vcsdir
                if self.opt_dryrun:
                    print(cmd_changedir + ';' + cmd_pull)
                else:
                    os.system(cmd_changedir + ';' + cmd_pull)
                counter = counter + 1

    def process_commit(self, cmdargs):
        if not cmdargs:
            self.usage(['intro', 'commit', 'filtering', 'common'])
            sys.exit(0)

        try:
            opts, args = getopt.getopt(cmdargs, 'adhqsu:' + self.filter_short, [ 'commit', 'dryrun', 'dry-run', 
                    'help', 'verbose', self.filter_long ])
        except getopt.GetoptError as err:
            print('Error', err)
            self.usage(['intro', 'commit', 'filtering', 'common'])
            sys.exit(0)
        for o, a in opts:
            if o in ('--commit'):
                self.opt_commit = True
            if o in ('--dryrun', '--dry-run'):
                self.opt_dryrun = True
            if o in ('-h', '--help'):
                self.usage(['intro', 'commit', 'filtering', 'common'])
                sys.exit()
            if o in ('-v', '--verbose'):
                self.opt_verbose = True
            self.apply_filtering(o, a)

        self.verify_filtering()

        if self.opt_commit:
            self.apply_translation_changes()

    def show_status(self, cmdargs):
        self.dir_po, self.dir_vcs = self.get_release_config(self.release)

        if not os.path.isdir(self.dir_vcs):
            print("The release you've entered has not been configured yet.")
            print("Please provide the name of a valid release or make sure to")
            print(" configure it first.")
            sys.exit(0)

        print('Language code: [%(lang)s]\t Language: %(langfull)s\t Username: %(u)s' % \
                { 'lang': self.language, 
                  'langfull': self.languagefull, 'u': self.username })
        print()
        print('VCS Directory:', self.dir_vcs)
        print('PO  Directory:', self.dir_po)
        print()
        dircontents = dircache.listdir(self.dir_vcs)
        dircontents = dircontents[:]
        print(len(dircontents), 'repositories found:') 
        print('\t', ', '.join(map(str, dircontents)))
        if os.path.exists(self.dir_po) or self.dir_po:
            podircontents = dircache.listdir(self.dir_po)
            podircontents = podircontents[:]
            try: 
                podircontents.remove(self.file_START)
            except ValueError as err:
                pass
            print(len(podircontents), 'PO files found:') 
            for pofile in podircontents:
                print('\t', pofile)
        else:
            print('No PO directory has been specified. Please specify')
            print('such a directory with --config --podir <path to dir>.')
            print('Exiting...')
        try:
            start_time = os.stat(self.dir_po + self.file_START).st_mtime
        except OSError:
            start_time = 0
        if start_time:
            print('Timestamp file START has date/time:',  datetime.ctime(datetime.fromtimestamp(start_time)))
        else:
            print('No START file exists')
        print('PO files that are newer than timestamp:')
        for pofile in podircontents:
            potime = os.stat(self.dir_po + pofile).st_mtime
            if start_time < potime:
                print('\t', datetime.ctime(datetime.fromtimestamp(potime)), '\t', pofile)

    def apply_translation_changes(self):
        vcsdircontents = dircache.listdir(self.dir_vcs)
        vcsdircontents = vcsdircontents[:]
        podircontents = dircache.listdir(self.dir_po)
        podircontents = podircontents[:]
        try:
            podircontents.remove(self.file_START)
        except:
            pass
        start_time = os.stat(self.dir_po + self.file_START).st_mtime
        for pofile in podircontents:
            print('VCSPATH', self.get_po_file_data(pofile))
            fileparts = pofile.split('.')
            try:
                if fileparts[0][-5:] != '-help':
                    modulename = fileparts[0]
                    translationtype = '/po/'
                else:
                    modulename = fileparts[0][:-5]
                    translationtype = '/help/' + self.language + '/'
                branchname = fileparts[1]
                languagename = fileparts[2]
                extensionname = fileparts[3]
            except IndexError as err:
                print("Error with", pofile)
                sys.exit(13)
            if self.language != languagename:
                print('Internal error: Language in config does not match language in PO files.')
                print('Exiting...')
                sys.exit(-11)
            if start_time < os.stat(self.dir_po + pofile).st_mtime:
                if self.opt_verbose:
                    destination =  self.dir_vcs + \
                        modulename + translationtype + languagename + '.' + extensionname
                    print('Copying', self.dir_po + pofile, 'to', destination)
                    try:
                        os.stat(destination)
                    except OSError as err:
                        print('but', destination, 'is not there')
                if not self.opt_dryrun:
                    shutil.copyfile(self.dir_po + pofile,  pofile)

    def get_po_file_data(self, pofile):
        if not self.gnome_release_data:
            self.parse_gnome_release_data()
        
        if self.gnome_release_data['release'] != self.release:
            print("Mismatched release data", self.release, self.gnome_release_data['release'])
        if self.gnome_release_data['language'] != self.language:
            print("Mismatched language data", self.language, self.gnome_release_data['language'])
        for cat in list(self.gnome_release_data['categories'].keys()):
            if self.category != '' and cat != self.category:
                continue
            for mod in self.gnome_release_data['categories'][cat]:
                if self.module != '' and mod != self.module:
                    continue
                for resource in self.gnome_release_data['categories'][cat][mod]['resource']:
                    if pofile == resource['pofile'].rsplit('/')[-1]:
                        return resource['vcspath']
        return None
        
    def is_empty(self):
        for dir in [self.dir_po]:
            dircontents = dircache.listdir(dir)
            dircontents = dircontents[:]
            if dircontents:
                return False
        return True

    def reset_hard(self, dir):
        dircontents = dircache.listdir(dir)
        dircontents = dircontents[:]
        if dircontents:
            for item in dircontents:
                if os.path.isdir(dir + item):
                    CMD = 'cd ' + dir + item + '; git reset --hard origin/master'
                    if self.opt_verbose:
                        print(CMD)
                    if not self.opt_dryrun:
                        print('Reseting hard', dir + item)
                        os.system(CMD)
                    else:
                        print('Would reset hard', dir + item)

    def do_cleanall(self, dir):
        dircontents = dircache.listdir(dir)
        dircontents = dircontents[:]
        if dircontents:
            for item in dircontents:
                if os.path.isdir(dir + item):
                    if not self.opt_dryrun:
                        print('Removing directory tree', dir + item)
                        shutil.rmtree(dir + item)
                    else:
                        print('Would remove directory tree', dir + item)

                else:
                    if not self.opt_dryrun:
                        print('Removing file', dir + item)
                        os.remove(dir + item)
                    else:
                        print('Would remove file', dir + item)
                        

    def init(self): 
        if self.opt_dryrun:
            self.process_stats('print')
        else:
            self.process_stats('execute')

    def parse_gnome_release_data(self):
        self.release = 'gnome-2-28'
        filename = 'managevcs-%s-%s.xml' % (self.language, self.release)
        filepath = os.path.join(os.curdir, filename)
        xmlurl = 'http://l10n.gnome.org/languages/' + self.language + '/' + self.release + '/xml'
        self.download_file(xmlurl, filepath)

        # An error page is about 2.5KB, a proper XML file is circa 50KB.
        if os.path.getsize(filepath) < 5000:
            print('Language', self.language, 'was not found.\nExiting...')
            print(xmlurl)
            os.remove(filepath)
            sys.exit(-7)

        self.gnome_release_data = self.parse_gnome_xml_file(filepath)

    def parse_gnome_xml_file(self, filename):
        try:
            xmlfile = open(filename, 'r')
            xmlfile.close
        except OSError:
            print('Could not open file ', filename, '. Aborting...')
            sys.exit(-1)
    
        contents = ''.join(xmlfile.readlines())
        
        mytarget = GNOMEI18nTarget.GNOMEI18nTarget()
        parser = etree.XMLParser(target = mytarget)
        result = etree.XML(contents, parser)
    
        return mytarget.get_stats()

    def usage(self, helpIDs):
        # Help text message
        help_intro = """gnome-i18n-manage-vcs, a tool that helps manage translation files from a VCS
Usage: gnome-i18n-manage-vcs <action> <options>
"""

        help_actions = """Please specify action. Available actions are:
\t* config       configures the local settings
\t* status       show detailed status of local files
\t* vcsmanage    repository management tasks
\t* poget        retrieval of PO files
\t* commit     commiting PO files
"""

        help_config = """config     Initial configuration
\t\t--language LANG     specify the language code per ISO 639
\t\t--languagefull LANGFULL  specify the full language name (such as 'Brazilian Portuguese')
\t\t--username USER     specify username USR (corresponds to SVN/GIT GNOME account)
\t-l                          list the configuration options                
"""

        help_status = """status      Show current status for a previously configured release.
"""

        help_vcsmanage = """vcsmanage   Local repository management (Module filtering applies)
\t\t--cleanall      cleans up the repository folder (USE WITH CARE, WIPES REPOSITORIES)
\t\t--removewc      erases the working copy in repositories (DOES NOT check for uncommitted changes)
\t\t--clone         clone repositories
\t\t--eponymous     make repositories eponymous (sets to new 'username')
\t\t--gitverbose    show progress when cloning (git 1.5 ignores this option).
\t\t--reset         reset each repository (git reset --hard origin/master)
\t\t--trim          erases the working copy
\t\t--update-vcs    update local repositories (runs git pull --rebase on each)
"""

        help_poget = """poget       Retrieve a selection of PO files (Module filtering required)
\t\t--cleanall      clears up the downloaded files (USE WITH CARE, WIPES PO FILES)
"""

        help_commit = """commit    Commit and push the translation work to the repositories
\t\t--commit        commit changes in repositories
\t\t--dry-run       do not really checkout/commit
"""

        help_filtering = """Module filtering  (applies to 'vcsmanage', 'poget', 'commit')
\t-c CAT  --category CAT      i18n category name CAT (such as 'desktop')
\t-m MODU --module MOD        i18n module name MOD (such as 'gnome-games')
\t-r REL  --release REL       GNOME release (such as 'gnome-2-26')
\t-t TYPE --transtype TYPE    optionally specify translation type, either ui or doc
"""

        help_common = """Common options
\t-d      --dry-run           do not really perform the action
\t-h      --help              this craft
\t-v      --verbose           show verbose output
"""

        help_help = """Invoke with --help for full help options."""

        help_messages = {
            'intro': help_intro,
            'actions': help_actions,
            'config': help_config,
            'status': help_status,
            'vcsmanage': help_vcsmanage,
            'poget': help_poget,
            'commit': help_commit,
            'filtering': help_filtering,
            'common': help_common,
            'help': help_help
        }

        for id in helpIDs:
            print(help_messages[id])

    def download_hook(self, blocks_transferred, block_size, file_size):
        """ A download hook to provide some feedback when downloading """
        if blocks_transferred == 0:
            if file_size > 0:
                if self.opt_verbose:
                    sys.stdout.write('Downloading', file_size, 'bytes: ')
                else:
                    if self.opt_verbose:
                        sys.stdout.write('Downloading: ')
        if self.opt_verbose:
            sys.stdout.write('#')
            sys.stdout.flush()


    def download_file(self, url, filepath):
        """
        Downloads a file provided a URL and saves it as filepath.
        """

        if self.opt_verbose:
            sys.stdout.write('Downloading', url, " ")
        # Download the file, regardless if it exists or not.
        try:
            urllib.request.urlretrieve(url, filepath, self.download_hook)
        except IOError as data_ioerror:
            (errno, strerror) = data_ioerror.args
            if self.opt_verbose:
                print()
            print('While trying to download', url)
            print('I/O error(%s): %s' % (errno, strerror))
            sys.exit(-1)
        except OSError as err:
            print('Unexpected error: ', err)
            sys.exit(-1)

        if self.opt_verbose:
            print(' done.')

    def createreleasedirectory(self, release):
        """
        Creates the directories required to save files for a given release.
        """

        # TODO: the po and vcs files should be variables and the final path
        # could be an attribute of the release itself.

        # First a directory for the release
        if not os.path.isdir(os.path.join(self.data_dir, release)):
            os.mkdir(os.path.join(self.data_dir, release))

        # Now a directory to store the PO files...
        self.dir_po = os.path.join(self.data_dir, release, 'po')
        if not os.path.isdir(self.dir_po):
            os.mkdir(self.dir_po)

        # ... and a directory to store the VCS files from a clone
        self.dir_vcs = os.path.join(self.data_dir, release, 'vcs')
        if not os.path.isdir(self.dir_vcs):
            os.mkdir(self.dir_vcs)

    def writeconfig(self):
        config = configparser.ConfigParser()

        try:
            config.add_section('GNOME-I18n-Manage-VCS')
            if self.language:
                config.set('GNOME-I18n-Manage-VCS', 'language', self.language)
            if self.languagefull:
                config.set('GNOME-I18n-Manage-VCS', 'languagefull', self.languagefull)
            if self.username:
                config.set('GNOME-I18n-Manage-VCS', 'username', self.username)
            #self.dir_vcs = os.path.join(self.data_dir, self.release, 'vcs/')
            #config.set('GNOME-I18n-Manage-VCS', 'vcsdir', self.dir_vcs)
            #self.dir_po = os.path.join(self.data_dir, self.release, 'po/')
            #config.set('GNOME-I18n-Manage-VCS', 'podir', self.dir_po)
        except configparser.NoOptionError as err:
            print('Error:', err)
            sys.exit(10)

        try:
            cf = open(self.conf_file, 'wb')
            config.write(cf)
            cf.close()
        except Exception as e:
            print("Oooops")

    def readconfig(self):
        """
        Reads the existing configuration file.
        """
        config = configparser.ConfigParser()

        if os.path.exists(self.conf_file):
            config.read(self.conf_file)

            try:
                self.language = config.get('GNOME-I18n-Manage-VCS', 'language')
                self.languagefull = config.get('GNOME-I18n-Manage-VCS', 'languagefull')
                self.username = config.get('GNOME-I18n-Manage-VCS', 'username')
                #self.dir_po = os.path.join(self.data_dir, self.release, 'po/')
                #self.dir_vcs = os.path.join(self.data_dir, self.release, 'vcs/')
            except configparser.NoOptionError as err:
                if not self.action_config:
                    print('Error:', str(err))
                    print('Please use --config and the relevant argument to set the missing setting')
                    print('Exiting...')
                    sys.exit(10)
        #else:
        #    print "The configuration file %s was not found." % self.conf_file
        #    print "It is required to perform the initial configuration, before issuing commands."
        #    sys.exit(10)

    def get_release_config(self, release):
        dir_po = os.path.join(self.data_dir, 'po/')
        dir_vcs = os.path.join(self.data_dir, 'vcs/')

        return dir_po, dir_vcs

    def apply_filtering(self, o, a):
        if o in ('-c', '--category'):
            self.category = a
        if o in ('-m', '--module'):
            self.module = a
        if o in ('-r', '--release'):
            self.release = a
        if o in ('--transtype'):
            if a in ['ui', 'domain']:
                self.transtype = 'domain'
            elif a in ['doc', 'document']:
                self.transtype = 'document'
            else:
                print('ERROR: Invalid transtype, expected on of ui, doc, domain, document')
                sys.exit(-4)

    def verify_filtering(self):
        if self.category == '' and self.module == '' and self.release == '' and self.transtype == '':
            if not self.opt_cleanall:
                print("Error: It is required to specify at least one of release, category, module or translation type.")
                sys.exit(8)

if __name__ == '__main__':
    start = GNOMEI18nManage(sys.argv)
